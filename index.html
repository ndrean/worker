<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workers & blobs</title>

</head>

<body>

    <h1>Examples of using web workers</h1>
    <p>Un Web Worker est donc une façon d’appeler un script JavaScript qui va s’exécuter dans un Thread différent de
        celui du
        script qui le crée. Il est possible pour les deux scripts de communiquer ensemble via l’envoi et la réception de
        messages. Un Web Worker n’est cependant pas léger et n’est pas à utiliser à tort ou à travers. La création est
        un
        processus coûteux, notamment en mémoire. Il peut cependant grandement soulager l’affichage et la mise à jour
        d’une page
        web si vous avez à réaliser des calculs complexes ou des opérations régulières qui peuvent ne rien changer à
        votre page.
        Typiquement, si vous voulez faire des vérifications régulières sur une API et comparer vos données en cache à
        vos
        données affichées pour savoir ce que vous allez modifier, ce peut être une bonne idée d’utiliser un Web Worker.
    </p>

    <hr>
    <p>To run a <em>Worker</em>, we declare it and reference the name of a <em>.js</em> file that contains the code the
        <em>Worker</em> will run. Then <em>main</em> communicates with the <em>Worker</em> by emmitting messages with
        the <em>postMessage</em> method, and listens to messages with <em>onmessage</em> (shortcut for
        <em>worker.addEventListener('message', callback)
        </em>)
        method. </p>
    <p>
        <button onClick="ping()">Ping</button><span> See response in console</span>
        <br>
        <button onClick="stopPing()"> Kill the worker</button>
    </p>
    <hr>
    <h5>Direct computation in a script</h5>
    <p>This button runs a code that will freeze the browser for approx 10s. Clic to test :
        <button onClick="longRun()">Test!</button><span id="longRun"> </span>
    </p>
    <h5>Parallel computation with a web worker</h5>
    <p>The same code run by a web worker. Becomes a background none blocking job.
        <button onClick="runWorker()">Test!</button><span id="workerRun"> </span>
    </p>


    <h1>Examples of using Blobs</h1>
    <h3> Stylesheet stored in a blob</h3>
    <p>We stored <em>CSS</em> in the a <em>blob</em>, and then create a <em>link</em> element, and set it's
        <em>href</em> attribute as the URL of the blob. We put the <em>h1</em> with background yellow and the
        <em>button</em> have text in red. </h1>
    </p>
    <h3>Exemple du display du data d'un blob avec FileReader</h3>
    <p>The test below is the data array of a <em>blob</em> and we use a <em>FileReader</em> to read asynchronously the
        data and when finished, the <em>loadend</em> event of the <em>FileReader</em> callback the attachment to the
        DOM.</p>
    <div id="insertFile"></div>

    <br>
    <h3>Exemple du display du data d'un blob via un link</h3>
    <p>We create an <em>'a'</em> link and sets it's <em>href</em> attribute to be the <em>URL</em> of a blob. Follow the
        link to see what's in the data of the blob</p>
    <div id="insertLink"></div>

    <br>
    <div id="linkbody"></div>

    <h3>Exemple of blob and web worker</h3>
    <p>We hardcode a <em>'script'</em> in the data array of a blob. When we create a <em>Worker</em>, we usaully link to
        a file. In this case, we link it to the URL of the blob. The <em>Worker</em> will then run the code of the
        <em>blob</em> </p>
    <p><button onClick="calc()">Calcutate</button> <span> and see result in console</span></p>

    <script>

        const longRun = () => {
            console.log("browser freezed!...")
            const start = Date.now(); // milliseconds
            let x = 0;
            for (let i = 0; i < 8000000000; i++) {
                x = x + i;
            }
            const result = -(start - Date.now()) / 1000
            console.log('ended in : ', result, ' seconds');
            document.getElementById('longRun').textContent = result
        }

        const worker = new Worker('long.js')
        const runWorker = () => {
            console.log("starting worker...")
            document.getElementById('workerRun').textContent = "No freeze, can display this, just // computing..."
            worker.postMessage("start")
        }
        worker.onmessage = (e) => {
            const result = e.data
            console.log(result)
            document.getElementById('workerRun').textContent = result
        }

        //////
        const worker1 = new Worker('worker.js');

        const ping = function () {
            worker1.postMessage("Ping")
        }
        worker1.addEventListener('message', (event) => {
            const response = event.data
            console.log(response);
        })
        // shortcut: worker1.onmessage = function (event) {...}


        const stopPing = function () {
            alert("this will terminate this worker")
            worker1.terminate()
        }




        ////////////////////////////////////
        // creating CSS style:  <link rel="stylesheet" href="blobURL">
        const styleBodyWithBlob = new Blob(
            ['h3, h1 { background-color: yellow; } button {color: red; font-size:20px;}'],
            { type: 'text/css' }
        );
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = URL.createObjectURL(styleBodyWithBlob);
        document.head.appendChild(link);

        ////////////////////////////////////////
        // FileReader and Blob
        const textBlobHtml = new Blob(
            ["<p>\"Workers allows a page to run Javascript on a background thread so the main UI thread can remain responsive. Workers do not have access to the DOM or any global variables in the main UI thread and must use the <code>postMessage()</Code method to communicate with the main thread.</p>",
                "<p>The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.\"</p>"
            ],
            { type: "text/html" }
        )
        // the FileReader lets web app load asynchronously contents of files-blobs
        const myReader = new FileReader();
        myReader.readAsText(textBlobHtml)
        // Handler executed once reading(blob content referenced to a variable) from blob is finished. 
        myReader.addEventListener("loadend", (e) => { // short-cut= myReader.onload = (e)=> {...}
            document.getElementById('insertFile').innerHTML = e.target.result;
        });

        ////////////////////////////////////////

        // the data of the blob will be displayed as the result of a link
        const blobLink = new Blob(
            ["<h1 style=\"color:red\">I am the data of the blob</h1 > ", " <p> Yet another line</p> "],
            { type: 'text/html' }
        )
        // we create a link to this data-blob
        const blobLinkURL = URL.createObjectURL(blobLink)

        // the link is added to the DOM which will display the data-blob
        document.getElementById('insertLink').innerHTML =
            ` <a href="${blobLinkURL}">This link</a> <span> will display the data (text/html) of a blob showed below
            :</span> `
    </script>



    <script>
        // instead of using an external file, we hardcode a script here and will pass this code into a blob
        // that will point to it.
        const blobCode = new Blob(
            ['onmessage = function(event) \{ console\.log(event)\; postMessage(event.data * event.data) \}\;'],
            { type: 'application/javascript' }
        );
        // we create a link to this code
        const codeURL = URL.createObjectURL(blobCode);

        // Creates and starts a background thread that runs the code pointed at by scriptURL of type 'string'
        const worker3 = new Worker(codeURL);

        /////////////////////////////
        // Workers use the postMessage() method to communicate with the main thread
        // this is triggered here with a clic button
        const calc = () => {
            const nb = prompt('enter a number')
            worker3.postMessage(nb); // we send the object 'nb' to the worker 
        }

        // Fires when the worker calls postMessage(). The message passed to postMessage is in event.data.
        worker3.onmessage = function (event) {
            console.log('worker returned: ', event.data);
        };
    </script>


</body>

</html>